#!/bin/bash
#
# dotfiles - CLI for managing dotfiles
#
# Usage:
#   dotfiles <command> [args]
#
# Commands:
#   status            Show VCS status of dotfiles repo
#   pull              Pull latest changes and apply them
#   edit              Open dotfiles in editor
#   install           Run main install script
#   install <tools>   Install specific tool(s)
#   update            Update installed tools (brew, nvim plugins, etc.)
#   doctor            Check if everything is set up correctly
#

set -e

# Verbose mode (set via -v or --verbose flag)
VERBOSE=false

# Load common utilities
# Resolve symlinks to find the real script location
REAL_SCRIPT="$0"
if [[ -L "$0" ]]; then
    REAL_SCRIPT="$(readlink "$0")"
fi
SCRIPT_DIR="$(cd "$(dirname "$REAL_SCRIPT")/.." && pwd)"
source "$SCRIPT_DIR/lib/common.sh"

# Helper for verbose logging
log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        echo "  $*"
    fi
}

# Get the install script for a tool (returns path or empty string)
get_install_script() {
    local tool_dir="$1"
    if [[ -f "$tool_dir/install" ]]; then
        echo "$tool_dir/install"
    elif [[ -f "$tool_dir/install.zsh" ]]; then
        echo "$tool_dir/install.zsh"
    fi
}

# Commands

cmd_status() {
    local dir
    dir="$(dotfiles_dir)"
    cd "$dir" || exit 1
    
    echo "Dotfiles: $dir"
    echo ""
    vcs_status
}

cmd_edit() {
    local dir
    dir="$(dotfiles_dir)"
    
    if [[ -n "$EDITOR" ]]; then
        $EDITOR "$dir"
    elif command -v nvim &>/dev/null; then
        nvim "$dir"
    elif command -v vim &>/dev/null; then
        vim "$dir"
    else
        echo "No editor found. Set \$EDITOR or install nvim/vim."
        exit 1
    fi
}

cmd_pull() {
    if is_omarchy; then
        echo "Skipping pull on Omarchy (using default configs)"
        return 0
    fi
    
    local dir
    dir="$(dotfiles_dir)"
    cd "$dir" || exit 1
    
    log_info "Pulling latest changes..."
    vcs_pull
    
    log_info "Applying changes..."
    apply_all
    
    log_success "Done!"
}

cmd_update() {
    log_info "Updating tools..."
    
    # Homebrew (macOS only)
    if is_macos && command -v brew &>/dev/null; then
        log_info "Updating Homebrew..."
        brew update && brew upgrade
    fi
    
    # Call update() for each tool that has it
    local dir
    dir="$(dotfiles_dir)"
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        local install_script
        install_script=$(get_install_script "$tool_dir")
        
        # Skip directories without install scripts
        [[ -n "$install_script" ]] || continue
        
        # Source the script and call update if it exists
        (
            source "$install_script"
            if declare -f update &>/dev/null; then
                log_info "Updating $tool_name..."
                update
            else
                log_verbose "Skipping $tool_name (no update function)"
            fi
        )
    done
    
    log_success "All tools updated!"
}

cmd_doctor() {
    local dir
    dir="$(dotfiles_dir)"
    
    echo "Dotfiles Doctor"
    echo "==============="
    echo ""
    echo "Location: $dir"
    echo ""
    
    # Check platform
    echo "Platform:"
    if is_codespaces; then
        echo "  GitHub Codespaces"
    elif is_omarchy; then
        echo "  Omarchy (Arch Linux)"
    elif is_macos; then
        echo "  macOS"
    elif is_arch; then
        echo "  Arch Linux"
    else
        echo "  Unknown"
    fi
    echo ""
    
    # Check all tools dynamically
    echo "Tools:"
    local installed=()
    local not_installed=()
    local unknown=()
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        local install_script
        install_script=$(get_install_script "$tool_dir")
        
        # Skip directories without install scripts
        [[ -n "$install_script" ]] || continue
        
        # Source the script and call check_installed if it exists
        local status
        status=$(
            source "$install_script"
            if declare -f check_installed &>/dev/null; then
                if check_installed; then
                    echo "installed"
                else
                    echo "not_installed"
                fi
            else
                echo "unknown"
            fi
        )
        
        case "$status" in
            installed) installed+=("$tool_name") ;;
            not_installed) not_installed+=("$tool_name") ;;
            unknown) unknown+=("$tool_name") ;;
        esac
    done
    
    # Output results
    for tool in "${installed[@]}"; do
        echo "  ✅ $tool"
    done
    for tool in "${not_installed[@]}"; do
        echo "  ❌ $tool"
    done
    for tool in "${unknown[@]}"; do
        echo "  ❓ $tool"
    done
    echo ""
    
    # Summary
    local total=$((${#installed[@]} + ${#not_installed[@]} + ${#unknown[@]}))
    echo "${#installed[@]}/$total tools installed"
    if [[ ${#not_installed[@]} -gt 0 ]]; then
        echo "Run 'dot install <tool>' to install missing tools"
    fi
}

apply_all() {
    local dir
    dir="$(dotfiles_dir)"
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        local install_script
        install_script=$(get_install_script "$tool_dir")
        
        # Skip directories without install scripts
        [[ -n "$install_script" ]] || continue
        
        (
            source "$install_script"
            if declare -f apply &>/dev/null; then
                log_info "Applying $tool_name..."
                apply
            else
                log_verbose "Skipping $tool_name (no apply function)"
            fi
        )
    done
}

# Get list of available tools (directories with install scripts)
get_available_tools() {
    local dir
    dir="$(dotfiles_dir)"
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        # Check for install script (could be 'install' or 'install.zsh')
        if [[ -f "$tool_dir/install" ]] || [[ -f "$tool_dir/install.zsh" ]]; then
            echo "$tool_name"
        fi
    done | sort
}

# Run install script for a single tool
install_tool() {
    local tool="$1"
    local dir
    dir="$(dotfiles_dir)"
    
    local install_script=""
    if [[ -f "$dir/$tool/install" ]]; then
        install_script="$dir/$tool/install"
    elif [[ -f "$dir/$tool/install.zsh" ]]; then
        install_script="$dir/$tool/install.zsh"
    fi
    
    if [[ -z "$install_script" ]]; then
        return 1
    fi
    
    log_info "Installing $tool..."
    
    # Determine interpreter based on extension
    if [[ "$install_script" == *.zsh ]]; then
        zsh "$install_script"
    else
        bash "$install_script"
    fi
}

cmd_install() {
    local dir
    dir="$(dotfiles_dir)"
    
    # No arguments: run main install script
    if [[ $# -eq 0 ]]; then
        log_info "Running main install script..."
        "$dir/install"
        return $?
    fi
    
    # With arguments: install specific tools
    local failed_tools=()
    local unknown_tools=()
    
    for tool in "$@"; do
        if [[ -f "$dir/$tool/install" ]] || [[ -f "$dir/$tool/install.zsh" ]]; then
            if ! install_tool "$tool"; then
                failed_tools+=("$tool")
            fi
        else
            unknown_tools+=("$tool")
        fi
    done
    
    # Report unknown tools
    if [[ ${#unknown_tools[@]} -gt 0 ]]; then
        echo ""
        log_error "Unknown tool(s): ${unknown_tools[*]}"
        echo ""
        echo "Available tools:"
        get_available_tools | while read -r t; do
            echo "  - $t"
        done
        echo ""
    fi
    
    # Report failed tools
    if [[ ${#failed_tools[@]} -gt 0 ]]; then
        log_warn "Failed to install: ${failed_tools[*]}"
    fi
    
    # Exit with error if any issues
    if [[ ${#unknown_tools[@]} -gt 0 ]] || [[ ${#failed_tools[@]} -gt 0 ]]; then
        return 1
    fi
    
    log_success "Done!"
}

show_help() {
    cat <<EOF
dotfiles - CLI for managing dotfiles

Usage:
  dotfiles [options] <command> [args]

Commands:
  status            Show VCS status of dotfiles repo
  pull              Pull latest changes and apply them
  edit              Open dotfiles in editor
  install           Run main install script
  install <tools>   Install specific tool(s), e.g. 'dotfiles install jj node'
  update            Update installed tools (brew, nvim plugins, etc.)
  doctor            Check if everything is set up correctly
  help              Show this help message

Options:
  -v, --verbose     Show verbose output (e.g., skipped tools)

Environment:
  DOTFILES_DIR    Override dotfiles directory location
  EDITOR          Editor to use for 'edit' command
EOF
}

# Parse global flags
while [[ "${1:-}" == -* ]]; do
    case "$1" in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Export VERBOSE for subshells
export VERBOSE

# Main dispatch
case "${1:-}" in
    status)
        cmd_status
        ;;
    pull)
        cmd_pull
        ;;
    edit)
        cmd_edit
        ;;
    install)
        shift
        cmd_install "$@"
        ;;
    update)
        cmd_update
        ;;
    doctor)
        cmd_doctor
        ;;
    help|--help|-h)
        show_help
        ;;
    "")
        show_help
        exit 1
        ;;
    *)
        echo "Unknown command: $1"
        echo "Run 'dotfiles help' for usage."
        exit 1
        ;;
esac
