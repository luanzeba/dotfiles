#!/bin/bash
#
# dotfiles - CLI for managing dotfiles
#
# Usage:
#   dotfiles <command> [args]
#
# Commands:
#   status            Show VCS status of dotfiles repo
#   pull              Pull latest changes and apply them
#   edit              Open dotfiles in editor
#   install           Run main install script
#   install <tools>   Install specific tool(s)
#   update            Update installed tools (brew, nvim plugins, etc.)
#   doctor            Check if everything is set up correctly
#   patch create      Create patch from uncommitted changes (Codespaces)
#   patch pull        Pull and apply patch from a Codespace (local)
#

set -e

# Verbose mode (set via -v or --verbose flag)
VERBOSE=false

# Load common utilities
# Resolve symlinks to find the real script location (portable across macOS/Linux)
REAL_SCRIPT="$0"
while [[ -L "$REAL_SCRIPT" ]]; do
    LINK_DIR="$(cd -P "$(dirname "$REAL_SCRIPT")" && pwd)"
    REAL_SCRIPT="$(readlink "$REAL_SCRIPT")"
    # Handle relative symlinks
    [[ "$REAL_SCRIPT" != /* ]] && REAL_SCRIPT="$LINK_DIR/$REAL_SCRIPT"
done
SCRIPT_DIR="$(cd -P "$(dirname "$REAL_SCRIPT")/.." && pwd)"
source "$SCRIPT_DIR/lib/common.sh"

# Helper for verbose logging
log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        echo "  $*"
    fi
}

# Get the install script for a tool (returns path or empty string)
get_install_script() {
    local tool_dir="$1"
    if [[ -f "$tool_dir/install" ]]; then
        echo "$tool_dir/install"
    elif [[ -f "$tool_dir/install.zsh" ]]; then
        echo "$tool_dir/install.zsh"
    fi
}

# Commands

cmd_status() {
    local dir
    dir="$(dotfiles_dir)"
    cd "$dir" || exit 1
    
    echo "Dotfiles: $dir"
    echo ""
    vcs_status
}

cmd_edit() {
    local dir
    dir="$(dotfiles_dir)"
    
    if [[ -n "$EDITOR" ]]; then
        $EDITOR "$dir"
    elif command -v nvim &>/dev/null; then
        nvim "$dir"
    elif command -v vim &>/dev/null; then
        vim "$dir"
    else
        echo "No editor found. Set \$EDITOR or install nvim/vim."
        exit 1
    fi
}

cmd_pull() {
    if is_omarchy; then
        echo "Skipping pull on Omarchy (using default configs)"
        return 0
    fi
    
    local dir
    dir="$(dotfiles_dir)"
    cd "$dir" || exit 1
    
    log_info "Pulling latest changes..."
    vcs_pull
    
    log_info "Applying changes..."
    apply_all
    
    log_success "Done!"
}

cmd_update() {
    log_info "Updating tools..."
    
    # Homebrew (macOS only)
    if is_macos && command -v brew &>/dev/null; then
        log_info "Updating Homebrew..."
        brew update && brew upgrade
    fi
    
    # Call update() for each tool that has it
    local dir
    dir="$(dotfiles_dir)"
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        local install_script
        install_script=$(get_install_script "$tool_dir")
        
        # Skip directories without install scripts
        [[ -n "$install_script" ]] || continue
        
        # Source the script and call update if it exists
        (
            source "$install_script"
            if declare -f update &>/dev/null; then
                log_info "Updating $tool_name..."
                update
            else
                log_verbose "Skipping $tool_name (no update function)"
            fi
        )
    done
    
    log_success "All tools updated!"
}

cmd_patch() {
    local subcmd="${1:-}"
    
    case "$subcmd" in
        create)
            cmd_patch_create
            ;;
        pull)
            shift
            cmd_patch_pull "$@"
            ;;
        ""|help)
            show_patch_help
            ;;
        *)
            echo "Unknown patch subcommand: $subcmd"
            show_patch_help
            exit 1
            ;;
    esac
}

cmd_patch_create() {
    if ! is_codespaces; then
        log_error "This command is intended for use in GitHub Codespaces"
        echo "Use 'dot patch pull' from your local machine to pull patches."
        exit 1
    fi
    
    local dir
    dir="$(dotfiles_dir)"
    cd "$dir" || exit 1
    
    local patch_file="/tmp/dotfiles.patch"
    
    if git diff --quiet HEAD; then
        log_error "No uncommitted changes to create patch from"
        exit 1
    fi
    
    git diff HEAD > "$patch_file"
    
    log_success "Patch created: $patch_file"
    echo ""
    echo "From your local machine, run:"
    echo "  dot patch pull"
}

cmd_patch_pull() {
    if is_codespaces; then
        log_error "This command is intended for use on your local machine"
        echo "Use 'dot patch create' in Codespaces to create a patch."
        exit 1
    fi
    
    if ! command -v gh &>/dev/null; then
        log_error "GitHub CLI (gh) is required but not installed"
        exit 1
    fi
    
    local codespace_name="${1:-}"
    local patch_file="/tmp/dotfiles.patch"
    local remote_patch="remote:/tmp/dotfiles.patch"
    
    # If no codespace specified, try ~/.codespace (set by csw)
    if [[ -z "$codespace_name" && -f "$HOME/.codespace" ]]; then
        codespace_name="$(cat "$HOME/.codespace")"
        log_info "Using codespace from ~/.codespace: $codespace_name"
    fi
    
    local gh_args=()
    if [[ -n "$codespace_name" ]]; then
        gh_args+=(-c "$codespace_name")
    fi
    
    log_info "Pulling patch from Codespace..."
    if ! gh cs cp "${gh_args[@]}" "$remote_patch" "$patch_file"; then
        log_error "Failed to copy patch from Codespace"
        echo ""
        echo "Make sure you've run 'dot patch create' in the Codespace first."
        exit 1
    fi
    
    log_success "Patch downloaded to $patch_file"
    echo ""
    echo "Patch contents:"
    echo "---------------"
    cat "$patch_file"
    echo "---------------"
    echo ""
    
    local dir
    dir="$(dotfiles_dir)"
    cd "$dir" || exit 1
    
    log_info "Applying patch to $dir..."
    if git apply "$patch_file"; then
        rm -f "$patch_file"
        log_success "Patch applied successfully!"
        echo ""
        echo "Next steps:"
        echo "  1. Review changes: git diff"
        echo "  2. Commit: git add -A && git commit -m 'Your message'"
        echo "  3. Push: git push"
        echo "  4. In Codespace: dot pull"
    else
        log_error "Failed to apply patch"
        echo "The patch may have conflicts. Try manually:"
        echo "  git apply --3way $patch_file"
        exit 1
    fi
}

show_patch_help() {
    cat <<EOF
dot patch - Transfer dotfiles changes from Codespaces

Usage:
  dot patch create          Create a patch from uncommitted changes (run in Codespace)
  dot patch pull [name]     Pull and apply patch from Codespace (run locally)

This workflow exists because Codespaces cannot push to your personal dotfiles
repo (the GITHUB_TOKEN is scoped to the workspace repo only).

Workflow:
  1. In Codespace:  dot patch create
  2. On local:      dot patch pull
  3. On local:      git commit && git push
  4. In Codespace:  dot pull

Arguments:
  name    Optional codespace name. If omitted, uses ~/.codespace (set by csw).
          If neither exists, gh will prompt interactively.
          Use 'gh cs list' to see available codespaces.
EOF
}

cmd_doctor() {
    [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]] && { show_doctor_help; return 0; }
    
    local dir
    dir="$(dotfiles_dir)"
    
    echo "Dotfiles Doctor"
    echo "==============="
    echo ""
    echo "Location: $dir"
    echo ""
    
    # Check platform
    echo -n "Platform: "
    if is_codespaces; then
        echo "GitHub Codespaces"
    elif is_omarchy; then
        echo "Omarchy (Arch Linux)"
    elif is_macos; then
        echo "macOS"
    elif is_arch; then
        echo "Arch Linux"
    else
        echo "Unknown"
    fi
    echo ""
    
    # Collect tool status into parallel arrays
    local tool_names=()
    local installed_statuses=()
    local configured_statuses=()
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        local install_script
        install_script=$(get_install_script "$tool_dir")
        
        # Skip directories without install scripts
        [[ -n "$install_script" ]] || continue
        
        tool_names+=("$tool_name")
        
        # Source the script and check status
        local statuses
        statuses=$(
            source "$install_script"
            
            # Check installed
            if declare -f check_installed &>/dev/null; then
                if check_installed; then
                    echo -n "yes "
                else
                    echo -n "no "
                fi
            else
                echo -n "unknown "
            fi
            
            # Check configured
            if declare -f check_configured &>/dev/null; then
                if check_configured; then
                    echo "yes"
                else
                    echo "no"
                fi
            else
                echo "na"  # Not applicable / no config needed
            fi
        )
        
        local inst_status conf_status
        read -r inst_status conf_status <<< "$statuses"
        installed_statuses+=("$inst_status")
        configured_statuses+=("$conf_status")
    done
    
    # Calculate column widths dynamically
    local tool_width
    tool_width=$(max_width 4 "${tool_names[@]}")
    local inst_width=9   # "Installed"
    local conf_width=10  # "Configured"
    
    # Print table header
    print_table_line "─" "$tool_width" "$inst_width" "$conf_width"
    print_table_row "$tool_width" "Tool" "$inst_width" "Installed" "$conf_width" "Configured"
    print_table_separator "$tool_width" "$inst_width" "$conf_width"
    
    # Print each tool's status
    local fully_configured=0
    local total=${#tool_names[@]}
    local i
    
    for ((i=0; i<total; i++)); do
        local tool="${tool_names[$i]}"
        local inst="${installed_statuses[$i]}"
        local conf="${configured_statuses[$i]}"
        
        # Convert to display symbols
        local inst_display conf_display
        case "$inst" in
            yes) inst_display="✅" ;;
            no) inst_display="❌" ;;
            *) inst_display="❓" ;;
        esac
        
        case "$conf" in
            yes) conf_display="✅" ;;
            no) conf_display="❌" ;;
            na) 
                # If installed and no config needed, show checkmark
                if [[ "$inst" == "yes" ]]; then
                    conf_display="✅"
                else
                    conf_display="-"
                fi
                ;;
            *) conf_display="❓" ;;
        esac
        
        # Count fully configured (installed + configured or no config needed)
        if [[ "$inst" == "yes" && ("$conf" == "yes" || "$conf" == "na") ]]; then
            ((fully_configured++))
        fi
        
        print_table_row "$tool_width" "$tool" "$inst_width" "   $inst_display" "$conf_width" "    $conf_display"
    done
    
    print_table_bottom "$tool_width" "$inst_width" "$conf_width"
    echo ""
    
    # Summary
    echo "$fully_configured/$total tools fully configured"
    
    if [[ $fully_configured -lt $total ]]; then
        echo "Run 'dot install <tool>' to install/configure missing tools"
    fi
    
    # Show recent errors if any
    local err_count
    err_count=$(error_count)
    if [[ "$err_count" -gt 0 ]]; then
        echo ""
        echo "Recent errors ($err_count total):"
        show_recent_errors 3
        echo ""
        echo "Run 'dot logs' for details"
    fi
}

cmd_logs() {
    local show_all=false
    local verbose=false
    local clear=false
    local last_n=10
    local filter_tool=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--all) show_all=true; shift ;;
            -v|--verbose) verbose=true; shift ;;
            -n|--last)
                shift
                if [[ -n "$1" && "$1" =~ ^[0-9]+$ ]]; then
                    last_n="$1"
                    shift
                else
                    log_error "--last requires a number"
                    return 1
                fi
                ;;
            --clear) clear=true; shift ;;
            -h|--help) show_logs_help; return 0 ;;
            -*) log_error "Unknown option: $1"; show_logs_help; return 1 ;;
            *) filter_tool="$1"; shift ;;
        esac
    done
    
    # Handle clear
    if [[ "$clear" == true ]]; then
        local count
        count=$(error_count)
        if [[ "$count" -gt 0 ]]; then
            clear_error_log
            log_success "Cleared $count error(s)"
        else
            log_info "No errors to clear"
        fi
        return 0
    fi
    
    # Check if log exists
    if [[ ! -f "$ERROR_LOG" ]] || [[ ! -s "$ERROR_LOG" ]]; then
        log_success "No errors recorded"
        return 0
    fi
    
    # Filter by tool if specified
    local log_content
    if [[ -n "$filter_tool" ]]; then
        log_content=$(grep "|$filter_tool|" "$ERROR_LOG" || true)
        if [[ -z "$log_content" ]]; then
            log_success "No errors for '$filter_tool'"
            return 0
        fi
    else
        log_content=$(cat "$ERROR_LOG")
    fi
    
    # Get total count and apply limit
    local total_count
    total_count=$(echo "$log_content" | wc -l | tr -d ' ')
    
    if [[ "$show_all" != true ]]; then
        log_content=$(echo "$log_content" | tail -n "$last_n")
    fi
    
    # Print header
    if [[ -n "$filter_tool" ]]; then
        echo "Errors for '$filter_tool' ($total_count total)"
    else
        echo "Recent Errors ($total_count total)"
    fi
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    if [[ "$verbose" == true ]]; then
        # Verbose view: show full error details
        echo "$log_content" | while IFS='|' read -r ts cmd tool code short full; do
            local date_part="${ts:0:19}"
            date_part="${date_part/T/ }"
            echo "[$date_part] $cmd ${tool:+$tool }(exit $code)"
            echo "────────────────────────────────────────────────────────────"
            # Unescape the full message
            echo -e "${full//\\n/$'\n'}" | sed 's/\\|/|/g'
            echo ""
        done
    else
        # Summary view: one line per error
        printf "%-16s  %-8s  %-12s  %s\n" "Timestamp" "Command" "Tool" "Message"
        printf "%-16s  %-8s  %-12s  %s\n" "────────────────" "────────" "────────────" "────────────────────────────────"
        echo "$log_content" | while IFS='|' read -r ts cmd tool _code short _full; do
            local date_part="${ts:0:16}"
            date_part="${date_part/T/ }"
            printf "%-16s  %-8s  %-12s  %s\n" "$date_part" "$cmd" "${tool:--}" "$short"
        done
    fi
    
    echo ""
    if [[ "$verbose" != true ]]; then
        echo "Run 'dot logs -v' for full details"
    fi
    echo "Run 'dot logs --clear' to clear"
}

apply_all() {
    local dir
    dir="$(dotfiles_dir)"
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        local install_script
        install_script=$(get_install_script "$tool_dir")
        
        # Skip directories without install scripts
        [[ -n "$install_script" ]] || continue
        
        (
            source "$install_script"
            if declare -f apply &>/dev/null; then
                log_info "Applying $tool_name..."
                apply
            else
                log_verbose "Skipping $tool_name (no apply function)"
            fi
        )
    done
}

# Get list of available tools (directories with install scripts)
get_available_tools() {
    local dir
    dir="$(dotfiles_dir)"
    
    for tool_dir in "$dir"/*/; do
        local tool_name
        tool_name=$(basename "$tool_dir")
        # Check for install script (could be 'install' or 'install.zsh')
        if [[ -f "$tool_dir/install" ]] || [[ -f "$tool_dir/install.zsh" ]]; then
            echo "$tool_name"
        fi
    done | sort
}

# Run install script for a single tool
install_tool() {
    local tool="$1"
    local dir
    dir="$(dotfiles_dir)"
    
    local install_script=""
    if [[ -f "$dir/$tool/install" ]]; then
        install_script="$dir/$tool/install"
    elif [[ -f "$dir/$tool/install.zsh" ]]; then
        install_script="$dir/$tool/install.zsh"
    fi
    
    if [[ -z "$install_script" ]]; then
        return 1
    fi
    
    log_info "Installing $tool..."
    
    # Determine interpreter based on extension
    if [[ "$install_script" == *.zsh ]]; then
        zsh "$install_script"
    else
        bash "$install_script"
    fi
}

cmd_install() {
    local dir
    dir="$(dotfiles_dir)"
    
    # No arguments: run main install script
    if [[ $# -eq 0 ]]; then
        log_info "Running main install script..."
        "$dir/install"
        return $?
    fi
    
    # With arguments: install specific tools
    local failed_tools=()
    local unknown_tools=()
    
    for tool in "$@"; do
        if [[ -f "$dir/$tool/install" ]] || [[ -f "$dir/$tool/install.zsh" ]]; then
            if ! install_tool "$tool"; then
                failed_tools+=("$tool")
            fi
        else
            unknown_tools+=("$tool")
        fi
    done
    
    # Report unknown tools
    if [[ ${#unknown_tools[@]} -gt 0 ]]; then
        echo ""
        log_error "Unknown tool(s): ${unknown_tools[*]}"
        echo ""
        echo "Available tools:"
        get_available_tools | while read -r t; do
            echo "  - $t"
        done
        echo ""
    fi
    
    # Report failed tools
    if [[ ${#failed_tools[@]} -gt 0 ]]; then
        log_warn "Failed to install: ${failed_tools[*]}"
    fi
    
    # Exit with error if any issues
    if [[ ${#unknown_tools[@]} -gt 0 ]] || [[ ${#failed_tools[@]} -gt 0 ]]; then
        return 1
    fi
    
    log_success "Done!"
}

show_doctor_help() {
    cat <<EOF
dot doctor - Check system health

Usage:
  dot doctor [-h|--help]

Shows a table of all tools with their installation and configuration status:
  - Installed: Whether the tool binary/command exists
  - Configured: Whether the tool's config files are symlinked

Status indicators:
  ✅  Installed/Configured
  ❌  Not installed/Not configured  
  ❓  No health check defined
  -   Not applicable (tool has no config)

Also displays any recent errors from the log.
EOF
}

show_logs_help() {
    cat <<EOF
dot logs - View installation and operation logs

Usage:
  dot logs                    Show recent errors (last 10)
  dot logs -a, --all          Show all logged errors
  dot logs -n, --last N       Show last N errors (default: 10)
  dot logs <tool>             Show errors for a specific tool
  dot logs --clear            Clear the error log
  dot logs -v, --verbose      Show full error details (not truncated)
  dot logs -h, --help         Show this help

Examples:
  dot logs                    # Recent errors, truncated
  dot logs helix              # Errors for helix only
  dot logs -v                 # Recent errors with full details
  dot logs --all -v           # Everything, full details
  dot logs --clear            # Clear log after reviewing

Errors are recorded during install, pull, and update operations.
The log is automatically cleared before 'dot install' (full) or 'dot pull'.
EOF
}

show_help() {
    cat <<EOF
dotfiles - CLI for managing dotfiles

Usage:
  dotfiles [options] <command> [args]

Commands:
  status            Show VCS status of dotfiles repo
  pull              Pull latest changes and apply them
  edit              Open dotfiles in editor
  install           Run main install script
  install <tools>   Install specific tool(s), e.g. 'dotfiles install jj node'
  update            Update installed tools (brew, nvim plugins, etc.)
  doctor            Check if everything is set up correctly
  logs              View installation and operation error logs
  patch create      Create patch from uncommitted changes (Codespaces)
  patch pull        Pull and apply patch from a Codespace (local)
  help              Show this help message

Options:
  -v, --verbose     Show verbose output (e.g., skipped tools)
  -h, --help        Show help for a command

Environment:
  DOTFILES_DIR    Override dotfiles directory location
  EDITOR          Editor to use for 'edit' command
EOF
}

# Parse global flags
while [[ "${1:-}" == -* ]]; do
    case "$1" in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Export VERBOSE for subshells
export VERBOSE

# Main dispatch
case "${1:-}" in
    status)
        cmd_status
        ;;
    pull)
        cmd_pull
        ;;
    edit)
        cmd_edit
        ;;
    install)
        shift
        cmd_install "$@"
        ;;
    update)
        cmd_update
        ;;
    doctor)
        shift
        cmd_doctor "$@"
        ;;
    logs)
        shift
        cmd_logs "$@"
        ;;
    patch)
        shift
        cmd_patch "$@"
        ;;
    help|--help|-h)
        show_help
        ;;
    "")
        show_help
        exit 1
        ;;
    *)
        echo "Unknown command: $1"
        echo "Run 'dotfiles help' for usage."
        exit 1
        ;;
esac
